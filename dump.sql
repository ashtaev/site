-- MySQL dump 10.13  Distrib 8.0.23, for Linux (x86_64)
--
-- Host: localhost    Database: base
-- ------------------------------------------------------
-- Server version	8.0.23

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `pages`
--

DROP TABLE IF EXISTS `pages`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `pages` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `description` text,
  `keywords` varchar(255) DEFAULT NULL,
  `text` text,
  `parent_id` int DEFAULT '0',
  `route` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=93 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `pages`
--

LOCK TABLES `pages` WRITE;
/*!40000 ALTER TABLE `pages` DISABLE KEYS */;
INSERT INTO `pages` VALUES (1,'Бесплатные инструменты ITNAV','Используйте наши бесплатные инструменты для проверки номеров телефонов, электронной почты, обнаружения символов Юникода и многого другого','кейвордс главная',NULL,0,NULL),(2,'Инструменты','Поставщик услуг текстовых сообщений TextMagic знакомит вас с последними новостями,\nтенденциями и вдохновляющими идеями о том, как развивать ваш малый бизнес.','инструменты',NULL,1,NULL),(3,'Статьи','Блог, поставщик услуг текстовых сообщений TextMagic знакомит вас с последними новостями,\n      тенденциями и вдохновляющими идеями о том, как развивать ваш малый бизнес.',NULL,NULL,1,NULL),(4,'Проверить ответ сервера','С помощью этого инструмента вы можете проверить ответ сервера для любого URL-адреса: коды состояния, заголовки HTTP и цепочку переадресации. Работает с протоколами HTTP и HTTPS.',NULL,'        <ul>\n            <li>\n                <b>Шаг №1:</b> Скопируйте и вставьте URL-адрес или строку текста, которую вы хотите кодировать или декодировать.\n            </li>\n            <li>\n                <b>Шаг № 2:</b> Закодируйте текст: «Зарезервированные символы» будут преобразованы в символы «%» и двузначные\n                шестнадцатеричные значения.<br>\n                <b>или</b><br>\n                Расшифровать текст: строка тарабарщины будет удалена, а текст будет преобразован в читаемый формат.\n            </li>\n        </ul>\n\n\n<h2>Что такое ответ сервера?</h2>\n\n<hr>\n\n<p>Ответ сервера, (так же HTTP-ответ) - это сообщение, передаваемое сетевым ресурсом клиентскому приложению, в ответ на его запрос. К примеру ответ сервера генерируется каждый раз когда браузер пользователя обращается к какой либо веб-странице в интернете. Http-ответ имеет четкую структуру, которая определяется спецификацией RFC 1945, и как правило, состоит из строки состояния, некоторых заголовков ответа, и тела документа.</p>\n\n<p>Типичный ответ сервера выглядит так:</p>\n\n<pre class=\"prettyprint lang-html\">\nHTTP/1.1 200 OK\nServer: nginx/1.18.0 (Ubuntu)\nDate: Wed, 18 Nov 2020 13:49:29 GMT\nContent-Type: text/html\nContent-Length: 612\nLast-Modified: Mon, 08 Jun 2020 08:51:20 GMT\nConnection: keep-alive\nETag: \"5eddfc08-264\"\nAccept-Ranges: bytes\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n    &lt;title&gt;Welcome to nginx!&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            width: 35em;\n            margin: 0 auto;\n            font-family: Tahoma, Verdana, Arial, sans-serif;\n        }\n    &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n        &lt;p&gt;If you see this page, the nginx web server is successfully installed and\n            working. Further configuration is required.&lt;/p&gt;\n\n        &lt;p&gt;For online documentation and support please refer to\n        &lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\n        Commercial support is available at\n        &lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n        &lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n\n<h2>Как сервер отправляет ответ</h2>\n\n<hr>\n\n<p>Сервер отвечает на запрос клиента следующим образом:</p>\n\n<ol>\n    <li>\n        Сервер отправляет специальное сообщение, называемое строкой состояния, содержащей три поля: версия HTTP, код состояния и описание. Первое поле, как следует из названия, указывает версию HTTP, которую сервер использует для формирования ответа. Код состояния - это трехзначное число, которое указывает результат запроса клиента. Описание, следующее за кодом состояния, представляет собой простой текст, который описывает код состояния. Например:\n        HTTP / 1.1 200 ОК\n        Эта строка состояния указывает, что сервер использует в своем ответе версию 1.1 HTTP. Код состояния 200 означает, что запрос клиента был успешным, и запрошенные данные будут предоставлены после заголовков.\n    </li>\n    <li>\n        После строки состояния сервер отправляет клиенту информацию, называемую заголовками, содержащими информацию о себе и запрошенном документе. Например:\n\n        HTTP/1.1 200 OK\n        Server: nginx/1.18.0 (Ubuntu)\n        Date: Mon, 16 Nov 2020 05:55:56 GMT\n        Content-Type: text/html\n        Content-Length: 612\n        Last-Modified: Mon, 08 Jun 2020 08:51:20 GMT\n        Connection: keep-alive\n        ETag: \"5eddfc08-264\"\n        Accept-Ranges: bytes\n\n        Пустая строка (в этой строке должен быть только символ CRLF), эта строка обозначает окончание полей заголовка.\n    </li>\n    <li>\n        Если запрос клиента завершился успехом, запрашиваемые данные отправляются. Эти данные (тело сообщения) могут быть копией файла или ответом программы CGI. Если запрос клиента не может быть выполнен, сервер отправляет сообщение, которое содержит дополнительные сведения о том, почему он не может быть выполнен.\n    </li>\n</ol>',2,'http-header-check'),(5,'Узнать IP адрес сайта','Сервис предназначен для того, чтобы узнать IP-адрес веб-сайта и страну, в которой расположен сервер этого веб-сайта.',NULL,NULL,2,'find-website-ip-address'),(6,'Кодирование и декодирование URL','Кодирование URL и декодирование URL, изменяют строку таким образом, чтобы она соответствовала правилам, установленным спецификацией Uniform Resource Locators',NULL,'<h2>Как использовать URL-кодировщик / декодер</h2>\n        <p>\n            Кодирование URL-адресов обычно используется, когда браузер отправляет данные на веб-сервер.\n            Вы можете использовать наш инструмент для автоматического URL-кодирования или декодирования\n            строки текста для обеспечения совместимости во всем мире.\n        </p>\n\n        <ul>\n            <li>\n                <b>Шаг №1:</b> Скопируйте и вставьте URL-адрес или строку текста, которую вы хотите кодировать или декодировать.\n            </li>\n            <li>\n                <b>Шаг № 2:</b> Закодируйте текст: «Зарезервированные символы» будут преобразованы в символы «%» и двузначные\n                шестнадцатеричные значения.<br>\n                <b>или</b><br>\n                Расшифровать текст: строка тарабарщины будет удалена, а текст будет преобразован в читаемый формат.\n            </li>\n        </ul>\n\n        <h2>Почему вам следует использовать кодировщик / декодер URL</h2>\n        <p>\n            Кодирование URL и декодирование URL, обычно называемое «процентным кодированием», изменяют\n            строку таким образом, чтобы она соответствовала правилам, установленным спецификацией Uniform\n            Resource Locators. Спецификация URL-адреса RFC 1738 требует, чтобы в структуре URL-адреса можно\n            было использовать только небольшой набор символов.\n        </p>\n        <p>\n            Этими символами являются: буквы верхнего регистра (от A до Z), буквы нижнего регистра\n            (от a до z), цифры (от 0 до 9), а также несколько «зарезервированных» символов\n            (знак доллара, подчеркивание, точка, закрытие / открытие скобка, одинарная кавычка,\n            звездочка, восклицательный знак, знак плюс и дефис).\n        </p>\n        <p>\n            Все неправильные символы должны быть заменены на%, за которым следует двузначное\n            шестнадцатеричное значение, представляющее символ в наборе символов ISO (например,\n            @ становится% 40); в противном случае вы можете столкнуться с проблемами при попытке\n            передать информацию через URL.\n        </p>\n\n        <h2>Почему мы создали этот инструмент</h2>\n        <p>\n            Раньше люди вручную кодировали URL-адреса специальные символы в строку кодирования.\n            Это была утомительная задача, которая обычно приводила к человеческой ошибке.\n            Мы создали этот инструмент, чтобы помочь вам кодировать / декодировать ссылки за считанные секунды.\n        </p>\n\n        <h2>Что такое кодировка URL?</h2>\n        <p>\n            Кодирование URL-адресов относится к кодированию определенных символов в унифицированном\n            указателе ресурсов (URL). Кодирование URL-адреса - это двухэтапный процесс:\n            строка символов кодируется в последовательность байтов, а затем каждый байт,\n            который не является буквой ASCII или цифрой, также преобразуется в шестнадцатеричное значение байта.\n        </p>\n\n        <h2>Что такое зарезервированные символы?</h2>\n        <p>\n            Иногда зарезервированные символы имеют особое значение, и кодирование URL-адресов позволяет\n            им сохранять свои специальные последовательности символов.\n            Другими словами, если зарезервированный символ имеет зарезервированную цель\n            в определенном контексте, схема URL-адреса диктует, что он закодирован в URL-адресе.\n        </p>\n        <p>\n            Кодирование URL-адреса преобразует символ в соответствующее ему байтовое значение в ASCII.\n            Это новое значение (две цифры, которым предшествует%) будет использоваться в URL-адресе\n            вместо зарезервированного символа.\n        </p>\n\n        <h2>Для чего нужны зарезервированные символы?</h2>\n        <p>\n            Вот список зарезервированных символов, их назначение и кодировка:\n        </p>\n\n        <table class=\"table\">\n            <thead>\n            <tr>\n                <th>Символ</th>\n                <th>Назначение в URL</th>\n                <th>Кодировка символов</th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr>\n                <td>/</td>\n                <td>Используется для разделения доменов и каталогов</td>\n                <td>%2F</td>\n            </tr>\n            <tr>\n                <td>#</td>\n                <td>Отделяет якоря</td>\n                <td>%23</td>\n            </tr>\n            <tr>\n                <td>+</td>\n                <td>Обозначает пробел</td>\n                <td>%2B</td>\n            </tr>\n            <tr>\n                <td>%</td>\n                <td>Указывает закодированный символ</td>\n                <td>%25</td>\n            </tr>\n            <tr>\n                <td>@</td>\n                <td>Отдельные данные пользователя и пароля от домена</td>\n                <td>%40</td>\n            </tr>\n            <tr>\n                <td>:</td>\n                <td>Отдельный протокол от адреса</td>\n                <td>%3B</td>\n            </tr>\n            <tr>\n                <td>&#60;пробел&#62;</td>\n                <td>Пробел, не рекомендуется в URL	+ или</td>\n                <td>%20</td>\n            </tr>\n            <tr>\n                <td>?</td>\n                <td>Отдельная строка запроса</td>\n                <td>%3F</td>\n            </tr>\n            </tbody>\n        </table>\n\n        <h2>Когда мне следует кодировать URL?</h2>\n        <p>\n            Строго говоря, вы всегда должны кодировать URL-адреса, особенно если ваша ссылка\n            или текст содержат неалфавитные символы, числа или специальные символы,\n            используемые вне их обычного контекста.\n        </p>\n\n        <h2>Должен ли я кодировать в URL незарезервированные символы?</h2>\n        <p>\n            Незарезервированные символы (прописные и строчные буквы, цифры и символы \'-\', \'_\', \'.\', \'~\')\n            Могут кодироваться, но не должны кодироваться.\n        </p>',2,'url-encoder-decoder'),(7,'URL-кодирование PHP',NULL,NULL,'<p>PHP содержит две встроенные функции: urlencode()и rawurlencode()для кодирования строки, чтобы ее можно было разместить внутри части запроса или сегмента пути URL-адреса.</p>\n\n<h2>Функция urlencode():</h2>\n\n<pre class=\"prettyprint lang-php\">\n# Syntax\nurlencode (string $str) : string\n</pre>\n\n<p>В urlencode()функция преобразует строку в URL закодирован формат, заменив все не алфавитно-цифровые символы , за исключением того, -и _с процентами ( %) знак , которым следуют два шестнадцатеричных цифр.</p>\n\n<p>Он преобразует пробел в знак плюса ( +) в соответствии с форматом MIME application / x-www-form-urlencoded . Это соответствует RFC 1738.</p>\n\n<b>пример</b>\n\n<pre class=\"prettyprint lang-php\">\n&#60;?php\necho urlencode(\"Hellö Wörld\") . \"\\n\";\n?&#62;\n</pre>\n\n<samp>\nHell%C3%B6+W%C3%B6rld\n</samp>\n\n<h2>Функция rawurlencode()</h2>\n\n<p>В rawurlencode()функции кодирует URL - адрес в соответствии с последним RFC 3986 . В отличие от urlencode()функции, он кодирует пробел %20вместо знака плюса ( +)</p>\n\n<pre>\n# Syntax\nrawurlencode (string $str) : string\n</pre>\n\n<p>В соответствии с RFC 3986, он возвращает строку , в которой все не алфавитно-цифровые символы , за исключением -, _, ., ~заменены с процента (%) знак за которым следуют два шестнадцатеричных цифр.</p>\n\n<p>Если вы не уверены, какую функцию следует использовать для кодирования URL-адресов, просто продолжайте rawurlencode().</p>\n\n<b>пример</b>\n\n<pre>\n<?php\necho rawurlencode(\"Hellö Wörld\") . \"\\n\";\n?>\n</pre>\n\n<samp>\nHell%C3%B6%20W%C3%B6rld\n</samp>\n\n<p>Читайте также: пример PHP декодирования URL</p>\n\n<h2>Ссылки</h2>\n<p>Функция PHP urlencode()</p>\n<p>Функция PHP rawurlencode()</p>\n',3,NULL),(8,'Что такое URL кодирование?',NULL,NULL,'<h2>Введение</h2>\n\n<p>URL (Uniform Resource Locator) - это адрес ресурса во всемирной паутине. URL - адрес имеет четко определенную структуру , которая была сформулирована в RFC 1738 по Тиму Бернерс-Ли, изобретатель всемирной паутины.</p>\n\n<p>Каждый URL-адрес подтверждает общий синтаксис, который выглядит следующим образом:</p>\n\n\n<pre>\nscheme:[//[user:password@]host[:port]]path[?query][#fragment]\n</pre>\n\n\n<p>Некоторые части синтаксиса URL, например [user:password@], устарели и редко используются из соображений безопасности. Ниже приведен пример URL-адреса, который вы чаще всего видите в Интернете.</p>\n\n<pre>\nhttps://www.google.com/search?q=hello+world#brs\n</pre>\n\n<p>В первоначальный RFC, определяющий синтаксис унифицированных указателей ресурсов (URL), было внесено множество улучшений. Текущий RFC, определяющий синтаксис Generic URI, - RFC 3986 . Этот пост содержит информацию из последнего документа RFC.<p>\n\n<p>Кодировка URL (процентное кодирование)\nURL-адрес состоит из ограниченного набора символов, принадлежащих набору символов US-ASCII. Эти символы включают цифры (0-9), буквы (AZ, AZ), а также несколько специальных символов ( \"-\", \".\", \"_\", \"~\").</p>\n\n<p>Управляющие символы ASCII (например , забой, вертикальные вкладки, горизонтальные вкладки, линия подача и т.д.), небезопасные символы , такие как space, \\, <, >, {, и }т.д., и любой символ за пределами ASCII кодировки не допускаются , чтобы быть помещены непосредственно в URL.</p>\n\n\n \n<p>Более того, есть некоторые символы, которые имеют особое значение в URL-адресах. Эти символы называются зарезервированными символами. Некоторые примеры зарезервированных символов являются ?, /, #, и :т.д. Любые данные , передаваемые как часть URL, будь то в строку запроса или сегмента пути, не должны содержать эти символы.</p>\n\n<p>Итак, что нам делать, когда нам нужно передать какие-либо данные в URL-адресе, содержащие эти запрещенные символы? Что ж, мы их кодируем!</p>\n\n<p>Кодирование URL-адресов преобразует зарезервированные, небезопасные и не-ASCII символы в URL-адресах в формат, который повсеместно принимается и понимается всеми веб-браузерами и серверами. Сначала он преобразует символ в один или несколько байтов. Затем каждый байт представлен двумя шестнадцатеричными цифрами, которым предшествует знак процента ( %) - (например %xy). Знак процента используется как escape-символ.</p>\n\n<p>Кодирование URL-адресов также называется процентным кодированием, поскольку оно использует знак процента ( %) в качестве escape-символа.</p>\n\n<h2>Пример кодировки URL</h2>\n\n<p>Пробел: один из наиболее часто встречающихся символов в кодировке URL space. spaceДесятичное значение символа ASCII равно 32, которое при преобразовании в шестнадцатеричное получается 20. Теперь мы просто ставим перед шестнадцатеричным представлением знак процента ( %), который дает нам значение в кодировке URL - %20.</p>\n\n<h2>Справочник по кодировке символов ASCII</h2>\n\n<p>В следующей таблице приведены ссылки на символы ASCII для их соответствующей закодированной формы URL.</p>\n\n<p>Обратите внимание, что кодирование буквенно-цифровых символов ASCII не требуется. Например, вам не нужно кодировать символ , \'0\'чтобы , %30как показано в следующей таблице. Его можно передавать как есть. Но кодировка по-прежнему действительна согласно RFC. Все символы, которые можно безопасно передавать внутри URL-адресов, в таблице окрашены в зеленый цвет.</p>\n \n<p>В следующей таблице используются правила, определенные в RFC 3986 для кодирования URL.</p>  \nПочему мы кодируем URL?\nURL-адреса (унифицированные указатели ресурсов) могут содержать только очень ограниченный набор символов из кодировки US-ASCII. Эти символы включают буквы верхнего и нижнего регистра ( A-Za-z), цифры ( 0-9) и специальные символы ( -_~.).\n\nНекоторые символы ASCII , как ?, &, =, /имеют особое значение в пределах URL. Другие символы ASCII, например backspace, newlineне печатаются. Все эти символы ASCII и любые символы, отличные от ASCII, должны быть закодированы, чтобы их можно было безопасно разместить внутри URL-адресов.\n\nКакие символы нельзя использовать в URL?\nВ URL запрещены символы следующего класса:\n\nЗарезервированные символы: некоторые символы, например : / ? # [ ] @ ! $ & \' ( ) * + , ; =, зарезервированы для специальных целей в URL-адресах. Например, символ ?используется для указания параметров запроса, символ &используется для разделения двух параметров запроса. Эти символы нельзя помещать в URL-адреса без кодировки.\n\nНепечатаемые символы: символы ASCII в диапазоне от 0 до 31 и 127 не печатаются. Их также называют управляющими символами. Эти символы нельзя использовать в URL-адресах.\n\nНебезопасные символы: другие символы ASCII, такие как space < > { } |` ^ \\, считаются небезопасными и не допускаются в URL-адресах.\n\nСимволы, отличные от ASCII: любые символы вне кодировки US-ASCII не допускаются в URL-адресах.',3,NULL),(9,'Ответ сервера',NULL,NULL,'<p>Когда вы посещаете веб-сайт, ваш браузер отправляет запрос на веб-сервер для получения данных или информации с него, например, HTML-файла (то есть веб-страницы). Как в запросе - HTTP- запросе - так и в ответе сервера, в дополнение к фактическим данным обменивается некоторая метаинформация. Об этом говорится в заголовке HTTP. Мы объясняем функцию заголовка HTTP и его наиболее важные поля.</p>\n\n<p>После получения и интерпретации сообщения запроса сервер отвечает сообщением ответа HTTP:</p>\n\n<ul>\n    <li>Строка состояния</li>\n    <li>Ноль или более полей заголовка (General | Response | Entity), за которыми следует CRLF</li>\n    <li>Пустая строка (т.е. строка, в которой ничего не предшествует CRLF) с указанием конца полей заголовка</li>\n    <li>Необязательно тело сообщения</li>\n</ul>\n\n<p>В следующих разделах объясняется каждый из объектов, используемых в ответном сообщении HTTP.</p>\n\n<h2>Строка состояния сообщения</h2>\n<p>Строка состояния состоит из версии протокола, за которым следует числовой код состояния и связанная с ним текстовая фраза. Элементы разделяются пробелами SP.</p>\n\n<pre>Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</pre>\n\n<h2>Версия HTTP</h2>\n<p>Сервер, поддерживающий HTTP версии 1.1, вернет следующую информацию о версии:</p>\n\n<pre>HTTP-Version = HTTP/1.1</pre>\n\n<h2>Код состояния</h2>\n<p>Элемент Status-Code представляет собой трехзначное целое число, где первая цифра Status-Code определяет класс ответа, а последние две цифры не имеют роли категоризации. Первая цифра имеет 5 значений:</p>\n\n<table class=\"table\">\n  <thead>\n    <tr>\n        <th>SN</th>\n        <th>Код и описание</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n        <td>1</td>\n        <td>\n        1xx: информационный<br>\n        Это означает, что запрос был получен и процесс продолжается.\n    </td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td>\n        2xx: Успех<br>\n        Это означает, что действие было успешно получено, понято и принято.\n        </td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>\n        3xx: перенаправление<br>\n        Это означает, что для выполнения запроса необходимо предпринять дальнейшие действия.\n        </td>\n    </tr>\n    <tr>\n        <td>4</td>\n        <td>\n        4xx: ошибка клиента<br>\n        Это означает, что запрос содержит неверный синтаксис или не может быть выполнен.\n        </td>\n    </tr>\n    <tr>\n        <td>5</td>\n        <td>\n        5xx: ошибка сервера<br>\n        Это означает, что серверу не удалось выполнить явно действительный запрос.\n        </td>\n    </tr>\n    </tbody>\n</table>\n	\n<p>Коды состояния HTTP являются расширяемыми, и приложения HTTP не обязаны понимать значение всех зарегистрированных кодов состояния. Список всех кодов состояния приведен в отдельной главе для справки.</p>\n\n<h2>Поля заголовка ответа</h2>\n<p>Мы изучим General-header и Entity-header в отдельной главе, когда будем изучать поля заголовка HTTP. А пока давайте проверим, что такое поля заголовка ответа.</p>\n\n<p>Поля заголовка ответа позволяют серверу передавать дополнительную информацию об ответе, которую нельзя поместить в строку состояния. Эти поля заголовка предоставляют информацию о сервере и о дальнейшем доступе к ресурсу, идентифицированному Request-URI.</p>\n\n<ul>\n    <li>Age</li>\n    <li>ETag</li>\n    <li>Location</li>\n    <li>Proxy-Authenticate</li>\n    <li>Retry-After</li>\n    <li>Server</li>\n    <li>Vary</li>\n    <li>WWW-Authenticate</li>\n</ul>\n\n<p>Вы можете ввести свои настраиваемые поля, если собираетесь написать собственный веб-клиент и сервер.</p>\n\n<h2>Примеры ответного сообщения</h2>\n<p>Теперь давайте соберем все это вместе, чтобы сформировать HTTP-ответ на запрос на получение страницы hello.htm с веб-сервера, запущенного на tutorialspoint.com.</p>\n\n<pre>\nHTTP/1.1 200 OK\nDate: Mon, 27 Jul 2009 12:28:53 GMT\nServer: Apache/2.2.14 (Win32)\nLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\nContent-Length: 88\nContent-Type: text/html\nConnection: Closed\n</pre>\n\n<pre>\n    &lt;html&gt;\n    &lt;body&gt;\n    &lt;h1&gt;Hello, World!&lt;/h1&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n</pre>\n\n<p>В следующем примере показано сообщение HTTP-ответа, отображающее состояние ошибки, когда веб-сервер не может найти запрошенную страницу:</p>\n\n<pre>\n    HTTP/1.1 404 Not Found\n    Date: Sun, 18 Oct 2012 10:36:20 GMT\n    Server: Apache/2.2.14 (Win32)\n    Content-Length: 230\n    Connection: Closed\n    Content-Type: text/html; charset=iso-8859-1\n</pre>\n\n<pre>\n    &lt;html&gt;\n    &lt;head&gt;\n       &lt;title&gt;404 Not Found&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n       &lt;h1&gt;Not Found&lt;/h1&gt;\n       &lt;p&gt;The requested URL /t.html was not found on this server.&lt;/p&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n</pre>\n\n<p>Ниже приведен пример сообщения HTTP-ответа, показывающего состояние ошибки, когда веб-сервер обнаружил неправильную версию HTTP в данном HTTP-запросе:</p>\n\n<pre>\n    HTTP/1.1 400 Bad Request\n    Date: Sun, 18 Oct 2012 10:36:20 GMT\n    Server: Apache/2.2.14 (Win32)\n    Content-Length: 230\n    Content-Type: text/html; charset=iso-8859-1\n    Connection: Closed\n</pre>\n\n<pre>\n    &lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n       &lt;title&gt;400 Bad Request&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n       &lt;h1&gt;Bad Request&lt;/h1&gt;\n       &lt;p&gt;Your browser sent a request that this server could not understand.&lt;/p&gt;\n       &lt;p&gt;The request line contained invalid characters following the protocol string.&lt;/p&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n</pre>',3,NULL),(10,'HTTP: все что нужно знать о протоколе',NULL,NULL,'<h1>HTTP: все что нужно знать о протоколе</h1>\n\n<p>Протокол передачи гипертекста (HTTP) - это протокол прикладного уровня для распределенных, совместных гипермедийных информационных систем. Это основа для передачи данных во всемирной паутине (то есть в Интернете) с 1990 года. HTTP - это общий протокол без сохранения состояния, который можно использовать для других целей, а также с использованием расширений его методов запроса, кодов ошибок и заголовков.</p>\n\n<p>По сути, HTTP - это протокол связи на основе TCP / IP, который используется для доставки данных (файлов HTML, файлов изображений, результатов запросов и т. Д.) Во всемирную паутину. Порт по умолчанию - TCP 80, но можно использовать и другие порты. Он обеспечивает стандартизированный способ взаимодействия компьютеров друг с другом. Спецификация HTTP определяет, как данные запросов клиентов будут создаваться и отправляться на сервер, и как серверы отвечают на эти запросы.</p>\n\n<h2>Основные характеристики</h2>\n<p>Есть три основных функции, которые делают HTTP простым, но мощным протоколом:</p>\n\n<p>HTTP без установления соединения: HTTP-клиент, т. Е. Браузер, инициирует HTTP-запрос, и после того, как запрос сделан, клиент ожидает ответа. Сервер обрабатывает запрос и отправляет ответ, после чего клиент разрывает соединение. Таким образом, клиент и сервер знают друг о друге только во время текущего запроса и ответа. Дальнейшие запросы выполняются при новом подключении, например, клиент и сервер являются новыми друг для друга.</p>\n\n<p>HTTP не зависит от носителя: это означает, что любой тип данных может быть отправлен по HTTP, если и клиент, и сервер знают, как обрабатывать содержимое данных. От клиента и сервера требуется указать тип контента, используя соответствующий MIME-тип.</p>\n\n<p>HTTP не имеет состояния: как упоминалось выше, HTTP не поддерживает соединение, и это прямой результат того, что HTTP является протоколом без состояния. Сервер и клиент знают друг друга только во время текущего запроса. После этого они оба забывают друг о друге. Из-за такого характера протокола ни клиент, ни браузер не могут сохранять информацию между различными запросами на веб-страницах.</p>\n\n<p>HTTP / 1.0 использует новое соединение для каждого обмена запрос / ответ, тогда как соединение HTTP / 1.1 может использоваться для одного или нескольких обменов запрос / ответ.</p>\n\n<h2>Базовая архитектура</h2>\n\n<p>На следующей диаграмме показана очень простая архитектура веб-приложения и показано, где находится HTTP:</p>\n\n<img src=\"\" alt=\"Архитектура HTTP\">\n\n<p>Протокол HTTP - это протокол запроса / ответа, основанный на архитектуре клиент / сервер, где веб-браузеры, роботы, поисковые системы и т. Д. Действуют как HTTP-клиенты, а веб-сервер действует как сервер.</p>\n\n<h2>Клиент</h2>\n\n<p>HTTP-клиент отправляет запрос на сервер в форме метода запроса, URI и версии протокола, за которым следует MIME-подобное сообщение, содержащее модификаторы запроса, информацию о клиенте и возможное содержимое тела через соединение TCP / IP.</p>\n\n<h2>Сервер</h2>\n<p>HTTP-сервер отвечает строкой состояния, включая версию протокола сообщения и код успеха или ошибки, за которым следует MIME-подобное сообщение, содержащее информацию о сервере, метаинформацию объекта и возможное содержимое тела объекта.</p>\n',3,NULL),(92,'Коды состояния HTTP','Обзор наиболее распространенных кодов состояния HTTP, возвращаемых сервером клиентскому программному обеспечению для определения результата запроса.',NULL,'<h2>Типы ответов</h2>\n\n<hr>\n\n<p>Коды состояния ответа HTTP указывают, был ли успешно выполнен конкретный запрос HTTP. Каждая группа содержит множество разных ответов, на этой странице вы найдете обзор наиболее распространенных кодов состояния HTTP. Ответы сгруппированы в пяти классах: информационные отклики, успешные отзывы, редиректы, ошибки клиента и ошибка сервера.</p>\n\n<h2>Сообщения о статусе</h2>\n\n<hr>\n\n<p>Сообщение, которое сопровождает код ответа сервера, не имеет значения для клиентов. Большинство клиентов полагаются только на сам код статуса «число». Сообщение следует рассматривать как рекомендацию, и клиент не обязательно должен их изучать.</p>\n\n<p>Сообщение о состоянии может отличаться в зависимости от версии HTTP или даже для разных документов RFC для одной и той же версии HTTP. А с введением HTTP / 2 протокол вообще не содержит сообщения о состоянии или причины.</p>\n\n<p class=\"alert alert-info\" role=\"alert\">Обратите внимание, что itnav.ru отправляет запросы только с версией 1.1 протокола HTTP.</p>\n\n<h2>Информационные ответы</h2>\n\n<hr>\n\n<p>Информационный ответ означает, что запрос был получен и понят. Он выдается временно, пока продолжается обработка запроса. Он предупреждает клиента, чтобы он дождался окончательного ответа.</p>\n\n<p class=\"alert alert-info\" role=\"alert\">Вы не увидите таких ответов при использовании itnav.ru</p>\n\n<h2>Успешные ответы</h2>\n\n<p>Коды состояния, указывающие на то, что сервер успешно обработал запрос.</p>\n\n<table class=\"table table-striped table-hover\">\n    <thead>\n        <tr>\n            <th>Код</th>\n            <th>Сообщение</th>\n            <th>Описание</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n                <span class=\"badge badge-success\">200</span>\n            </td>\n            <td>\n                OK\n            </td>\n            <td>\n                Сервер успешно обработал запрос. Обычно это означает, что сервер предоставил запрошенную страницу.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-success\">204</span>\n            </td>\n            <td>\n                Без содержания\n            </td>\n            <td>\n                Сервер отправил действительный ответ на запрос клиента, который содержит только информацию заголовка (т.е. не содержит тела сообщения). Веб-клиенты могут использовать этот статус для более эффективной обработки ответов сервера, например, избегая ненужного обновления страниц.\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<h2>Сообщения перенаправления</h2>\n\n<p>Для выполнения запроса необходимы дальнейшие действия. Часто эти коды состояния используются для перенаправления.</p>\n\n<table class=\"table table-striped table-hover\">\n    <thead>\n        <tr>\n            <th>Код</th>\n            <th>Сообщение</th>\n            <th>Описание</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n                <span class=\"badge badge-info\">301</span>\n            </td>\n            <td>\n                Переехал навсегда\n            </td>\n            <td>\n                Запрошенная страница была навсегда перемещена в новое место. Когда сервер возвращает этот ответ, он автоматически перенаправляет инициатора запроса в новое место. В ответе также должно быть указано это местоположение. Он сообщает клиенту использовать новый URL-адрес в следующий раз, когда он захочет получить тот же ресурс.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-info\">302</span>\n            </td>\n            <td>\n                Найдено / временно перемещено\n            </td>\n            <td>\n                В настоящее время сервер отвечает на запрос страницей из другого местоположения, но запрашивающая сторона должна продолжать использовать исходное местоположение для будущих запросов.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-info\">304</span>\n            </td>\n            <td>\n                Не изменено\n            </td>\n            <td>\n                Запрошенная страница не изменялась с момента последнего запроса. Когда сервер возвращает этот ответ, он не возвращает содержимое страницы.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-info\">307</span>\n            </td>\n            <td>\n                Временное перенаправление\n            </td>\n            <td>\n                В настоящее время сервер отвечает на запрос страницей из другого местоположения, но запрашивающая сторона должна продолжать использовать исходное местоположение для будущих запросов. Между кодом состояния 302 и кодом состояния 307 очень мало различий, но вы можете использовать оба, чтобы временно указать пользователям на другой URL. Этот код состояния имеет ту же семантику, что и код ответа HTTP 302 Found, за исключением того, что агент пользователя не должен изменять используемый метод HTTP.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-info\">308</span>\n            </td>\n            <td>\n                Постоянное перенаправление\n            </td>\n            <td>\n                Это означает, что ресурс теперь постоянно находится по другому URI, указанному в заголовке Location: HTTP Response. Он имеет ту же семантику, что и код ответа HTTP 301 Moved Permanently, за исключением того, что пользовательский агент не должен изменять используемый метод HTTP.\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<h2>Ответы клиента на ошибку</h2>\n\n<p>Эти коды состояния указывают на то, что в запросе, вероятно, была ошибка, из-за которой сервер не смог его обработать.</p>\n\n<table class=\"table table-striped table-hover\">\n    <thead>\n        <tr>\n            <th>Код</th>\n            <th>Сообщение</th>\n            <th>Описание</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n                <span class=\"badge badge-warning\">400</span>\n            </td>\n            <td>\n                Плохой запрос\n            </td>\n            <td>\n                Сервер не понял синтаксис запроса.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-warning\">401</span>\n            </td>\n            <td>\n                Неавторизованный\n            </td>\n            <td>\n                Запрос требует аутентификации, прежде чем к ресурсу можно будет получить доступ, клиент должен быть авторизован сервером. Сервер может вернуть этот ответ для страницы за логином.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-warning\">403</span>\n            </td>\n            <td>\n                Запрещено\n            </td>\n            <td>\n                Сервер отклоняет запрос. В отличие от неавторизованного ответа 401, аутентификация не имеет значения.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-warning\">404</span>\n            </td>\n            <td>\n                не обнаружена\n            </td>\n            <td>\n                Сервер не может найти запрошенную страницу. Например, сервер часто возвращает этот код, если запрос относится к странице, которой нет на сервере.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-warning\">408</span>\n            </td>\n            <td>\n                Тайм-аут запроса\n            </td>\n            <td>\n                Запрос, который вы отправили на сервер веб-сайта (например, запрос на загрузку веб-страницы), занял больше времени, чем сервер веб-сайта был готов ждать. Другими словами, ваше соединение с сайтом «истекло».\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-warning\">410</span>\n            </td>\n            <td>\n                Ушел\n            </td>\n            <td>\n                Сервер возвращает этот ответ, когда запрошенный ресурс был окончательно удален. Он похож на код 404 (не найден), но иногда используется вместо кода 404 для ресурсов, которые раньше существовали, но больше не существуют. Если ресурс был перемещен безвозвратно, вы должны использовать 301, чтобы указать новое местоположение ресурса.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-warning\">429</span>\n            </td>\n            <td>\n                Слишком много запросов\n            </td>\n            <td>\n                Клиент отправил слишком много запросов за заданный промежуток времени («ограничение скорости»).\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n<h2>Ответы на ошибку сервера</h1>\n\n<p>Эти коды состояния указывают на то, что сервер знает, что произошла ошибка или не может выполнить запрос.</p>\n\n<table class=\"table table-striped table-hover\">\n    <thead>\n        <tr>\n            <th>Код</th>\n            <th>Сообщение</th>\n            <th>Описание</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>\n                <span class=\"badge badge-danger\">500</span>\n            </td>\n            <td>\n                Внутренняя Ошибка Сервера\n            </td>\n            <td>\n                Сервер обнаружил то, чего не ожидал, и не смог выполнить запрос.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-danger\">502</span>\n            </td>\n            <td>\n                Плохой шлюз\n            </td>\n            <td>\n                Сервер получил неверный ответ от другого сервера.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-danger\">503</span>\n            </td>\n            <td>\n                Сервис недоступен\n            </td>\n            <td>\n                Сервер в настоящее время недоступен (из-за перегрузки сервера или из-за того, что он недоступен для обслуживания). Как правило, это временное состояние.\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <span class=\"badge badge-danger\">504</span>\n            </td>\n            <td>\n                Ошибка тайм-аута шлюза\n            </td>\n            <td>\n                Сервер не получил своевременного ответа от другого сервера, к которому он обращался, при попытке загрузить веб-страницу или выполнить другой запрос браузера. Другими словами, ошибки 504 обычно указывают на то, что другой компьютер, на котором веб-сайт, на котором вы получаете сообщение 504, не управляет, но полагается на него, не взаимодействует с ним достаточно быстро.\n            </td>\n        </tr>\n    </tbody>\n</table>\n',3,NULL);
/*!40000 ALTER TABLE `pages` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-04-17 17:39:18
